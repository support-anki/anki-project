<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>図あり教材（共通テンプレート・正誤記録対応）</title>
  <!-- Leaflet（SRIなしで確実ロード） -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root{
      --bg:#f7f7fb; --card:#fff; --text:#222; --muted:#667085;
      --brand:#3b4675; --accent:#22c55e; --danger:#ef4444;
    }
    html,body{height:100%} body{margin:0;background:var(--bg);color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP","Yu Gothic",Meiryo,sans-serif}
    header{position:sticky;top:0;z-index:50;background:rgba(255,255,255,.9);backdrop-filter:blur(6px);border-bottom:1px solid #e5e7eb}
    .wrap{max-width:1200px;margin:0 auto;padding:12px 16px}
    .title{font-size:18px;font-weight:700}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-top:8px}
    .pill{display:inline-flex;align-items:center;gap:6px;border:1px solid #ddd;background:#fff;border-radius:999px;padding:6px 10px;font-size:13px}
    .btn{cursor:pointer;border:1px solid #ddd;border-radius:10px;padding:8px 12px;font-size:14px;background:#fff}
    .btn.primary{background:var(--brand);color:#fff;border-color:var(--brand)}
    .btn.ghost{background:transparent}
    .layout{display:grid;grid-template-columns:1fr 380px;gap:12px;max-width:1200px;margin:12px auto;padding:0 16px 24px}
    #map{width:100%;height:calc(100vh - 150px);border-radius:14px;background:#e9edf3}
    aside{background:var(--card);border:1px solid #e5e7eb;border-radius:14px;display:flex;flex-direction:column}
    .aside-head{padding:10px;border-bottom:1px solid #eef2f6;display:flex;align-items:center;justify-content:space-between}
    .tabs{display:flex;gap:6px;flex-wrap:wrap}
    .tab{border:1px solid #ddd;border-radius:999px;padding:6px 10px;font-size:13px;cursor:pointer}
    .tab.active{background:var(--brand);color:#fff;border-color:var(--brand)}
    .aside-body{padding:12px;overflow:auto;display:grid;gap:10px}
    .qitem{border:1px solid #ddd;border-radius:12px;padding:10px;background:#fff}
    .qitem.correct{border-color:#bbf7d0;background:#f0fff4}
    .qitem.wrong{border-color:#fecaca;background:#fff5f5}
    .qtop{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .qid{font-weight:700;letter-spacing:.03em}
    .chip{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #ddd}
    .chip.ok{background:#dcfce7;border-color:#86efac}
    .chip.bad{background:#fee2e2;border-color:#fca5a5}
    .answer{background:#f8fafc;border:1px dashed #d8dee9;border-radius:10px;padding:8px;font-size:14px}
    .num-marker{width:28px;height:28px;border-radius:50%;display:grid;place-items:center;font-weight:700;
      border:2px solid #fff;box-shadow:0 2px 6px rgba(0,0,0,.2);background:#64748b;color:#fff}
    .num-marker.dim{background:#94a3b8}
    .num-marker.ok{background:var(--accent)}
    .num-marker.bad{background:var(--danger)}
    @media (max-width:960px){.layout{grid-template-columns:1fr} #map{height:48vh}}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <div class="title" id="pageTitle">図あり教材</div>
      <div class="toolbar">
        <span class="pill"><input type="checkbox" id="toggleAnswers"><label for="toggleAnswers">答えを常に表示</label></span>
        <span class="pill"><input type="checkbox" id="toggleLabels" checked><label for="toggleLabels">番号ラベルを表示</label></span>
        <button class="btn" id="fitBtn">全体表示</button>
        <button class="btn" id="resetBtn" title="未表示と正誤記録をリセット">未表示・記録をリセット</button>
        <button class="btn" id="exportBtn" title="表示中データをJSONでコピー">JSONをコピー</button>
        <button class="btn" id="editBtn" title="編集モード切替 (ドラッグで座標調整)">編集モード</button>
      </div>
    </div>
  </header>

  <main class="layout">
    <div id="map" aria-label="地図表示"></div>
    <aside>
      <div class="aside-head">
        <div class="tabs" id="imgTabs" aria-label="画像タブ"></div>
        <div class="hint" id="counter">—</div>
      </div>
      <div class="aside-body" id="qList" aria-label="問題リスト"></div>
    </aside>
  </main>
  <div style="text-align:center;color:#94a3b8;font-size:12px;padding:8px 16px 18px;">
    番号をクリックすると答えが表示されます。編集は ?edit=1 をURLに付けると有効。正解/誤答は端末に保存されます。
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // --- クエリ処理 ---
  const qs = new URLSearchParams(location.search);
  const dataUrl = qs.get('data');
  const pageTitle = qs.get('title') || '図あり教材';
  const editFromQS = qs.get('edit') === '1';
  document.getElementById('pageTitle').textContent = pageTitle;

  // --- 要素参照 ---
  const els = {
    map: document.getElementById('map'),
    tabs: document.getElementById('imgTabs'),
    qList: document.getElementById('qList'),
    counter: document.getElementById('counter'),
    fitBtn: document.getElementById('fitBtn'),
    resetBtn: document.getElementById('resetBtn'),
    exportBtn: document.getElementById('exportBtn'),
    editBtn: document.getElementById('editBtn'),
    toggleAnswers: document.getElementById('toggleAnswers'),
    toggleLabels: document.getElementById('toggleLabels'),
  };

  if (!dataUrl) {
    alert('data クエリにJSONのURLを指定してください。\n例: /modules/img.html?data=../assets/data/geo/mapdata/ge-kyushu.json&title=九州地方の地図');
  }

  // --- 状態 ---
  const state = {
    data: null,
    map: null,
    imageLayers: {}, // {imgId: { layer, bounds, meta }}
    markers: {},     // {pointId: marker | null} （nullは非表示指定で未生成）
    activeImgId: null,
    revealed: new Set(JSON.parse(localStorage.getItem(storeKey('revealed')) || '[]')),
    results: JSON.parse(localStorage.getItem(storeKey('results')) || '{}'), // {id: 'correct'|'wrong'}
    edit: editFromQS,
  };

  function storeKey(key){ return `anki-img:${dataUrl}:${key}`; }
  function saveRevealed(){ localStorage.setItem(storeKey('revealed'), JSON.stringify([...state.revealed])); }
  function saveResults(){ localStorage.setItem(storeKey('results'), JSON.stringify(state.results)); }
  function resetProgress(){ state.revealed.clear(); state.results = {}; saveRevealed(); saveResults(); renderList(); refreshMarkersVisibility(); }

  // --- Leaflet 初期化 ---
  const map = L.map('map', { crs: L.CRS.Simple, minZoom: -4, zoomSnap: 0.1 });
  state.map = map;

  // --- UI イベント ---
  els.fitBtn.addEventListener('click', () => fitActive());
  els.resetBtn.addEventListener('click', () => resetProgress());
  els.toggleAnswers.addEventListener('change', () => renderList());
  els.toggleLabels.addEventListener('change', () => refreshMarkersVisibility());
  els.exportBtn.addEventListener('click', exportJSON);
  els.editBtn.addEventListener('click', () => setEditMode(!state.edit));

  // --- データ読込 ---
  fetch(dataUrl, { cache: 'no-store' })
    .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
    .then(json => {
      state.data = json;
      if (json.title) document.getElementById('pageTitle').textContent = json.title;
      setupImages(json.images);
      setupMarkers(json.points);
      renderList();
      fitActive();
      setEditMode(state.edit);
    })
    .catch(err => { console.error(err); alert('JSONの読み込みに失敗しました。パスとCORS設定を確認してください。'); });

  // --- 画像処理 ---
  function setupImages(images){
    if (!Array.isArray(images) || images.length === 0) throw new Error('images が空です。');
    els.tabs.innerHTML = '';
    images.forEach((img, idx) => {
      const bounds = [[0,0], [img.height, img.width]];
      const layer = L.imageOverlay(img.src, bounds, { opacity: 1, interactive: false });
      state.imageLayers[img.id] = { layer, bounds, meta: img };
      const t = document.createElement('button');
      t.className = 'tab' + (idx===0 ? ' active' : '');
      t.textContent = img.label || img.id || `画像${idx+1}`;
      t.addEventListener('click', () => setActiveImage(img.id));
      els.tabs.appendChild(t);
      if (idx===0) {
        state.activeImgId = img.id;
        layer.addTo(map);
        map.setMaxBounds(bounds);
        map.fitBounds(bounds);
      }
    });
  }

  function setActiveImage(imgId){
    if (imgId === state.activeImgId) return;
    Object.entries(state.imageLayers).forEach(([id, obj]) => {
      if (id === imgId) { if (!map.hasLayer(obj.layer)) obj.layer.addTo(map); }
      else { if (map.hasLayer(obj.layer)) map.removeLayer(obj.layer); }
    });
    state.activeImgId = imgId;
    refreshMarkersVisibility();
    [...els.tabs.children].forEach(btn => btn.classList.remove('active'));
    const idx = Object.keys(state.imageLayers).indexOf(imgId);
    if (els.tabs.children[idx]) els.tabs.children[idx].classList.add('active');
    fitActive();
    renderList();
  }

  function fitActive(){ const cur = state.imageLayers[state.activeImgId]; if (cur) map.fitBounds(cur.bounds, { padding:[10,10] }); }

  // --- マーカー処理（marker/list/hideMarkers 対応） ---
  function setupMarkers(points){
    if (!Array.isArray(points)) return;
    points.forEach(pt => {
      const imgMeta = (state.imageLayers[pt.img]?.meta) || {};
      const hideByImage = imgMeta.hideMarkers === true;   // 画像側既定
      const hideByPoint = pt.marker === false;            // 問題側個別
      const showMarker = !(hideByImage || hideByPoint);

      if (showMarker) {
        const marker = L.marker([pt.y, pt.x], { draggable: state.edit, icon: makeNumIcon(pt) });
        marker.addTo(map);
        marker.on('click', () => reveal(pt.id));
        if (state.edit) marker.on('dragend', (e) => onDrag(pt, e));
        state.markers[pt.id] = marker;
      } else {
        // 非表示指定：リストや正誤のためIDだけ保持
        state.markers[pt.id] = null;
      }
    });
    refreshMarkersVisibility();
  }

  function refreshMarkersVisibility(){
    const active = state.activeImgId;
    const showLabels = els.toggleLabels.checked;
    Object.entries(state.markers).forEach(([id, marker]) => {
      const pt = state.data.points.find(p => p.id === id);
      if (!pt) return;
      const imgMeta = (state.imageLayers[pt.img]?.meta) || {};
      const hideByImage = imgMeta.hideMarkers === true;
      const hideByPoint = pt.marker === false;
      const showMarker = !(hideByImage || hideByPoint);
      const visible = pt.img === active;

      if (!marker) return; // 生成していない（非表示指定）

      if (visible && showMarker) {
        if (!map.hasLayer(marker)) marker.addTo(map);
        marker.setIcon(makeNumIcon(pt, !showLabels));
      } else {
        if (map.hasLayer(marker)) map.removeLayer(marker);
      }
    });
  }

  function makeNumIcon(pt, hideNumber){
    const num = pt.id.replace(/^0+/, '') || pt.id;
    const res = state.results[pt.id];
    let cls = 'num-marker';
    if (!state.revealed.has(pt.id)) cls += ' dim';
    if (res === 'correct') cls += ' ok';
    if (res === 'wrong') cls += ' bad';
    const html = `<div class="${cls}">${hideNumber ? '' : num}</div>`;
    return L.divIcon({ html, className: '', iconSize:[28,28], iconAnchor:[14,14] });
  }

  // --- リスト表示（list:false で除外） ---
  function renderList(){
    const always = els.toggleAnswers.checked;
    const active = state.activeImgId;
    const list = state.data.points
      .filter(p => p.img === active && p.list !== false)
      .sort((a,b)=>a.id.localeCompare(b.id,'ja'));

    els.qList.innerHTML = '';
    els.counter.textContent = `${state.revealed.size} / ${state.data.points.length}`;

    list.forEach(pt => {
      const shown = always || state.revealed.has(pt.id);
      const res = state.results[pt.id] || null;
      const card = document.createElement('div');
      card.className = 'qitem' + (res==='correct' ? ' correct' : res==='wrong' ? ' wrong' : '');
      card.innerHTML = `
        <div class="qtop">
          <div class="status">
            <span class="qid">${pt.id}</span>
            ${res==='correct'?'<span class="chip ok">✅ 正解</span>': res==='wrong'?'<span class="chip bad">❌ 誤答</span>':''}
          </div>
          <div class="qactions">
            <button class="btn" data-action="focus">地図</button>
            <button class="btn primary" data-action="reveal">${shown?'隠す':'表示'}</button>
            <button class="btn ghost" data-action="ok" title="正解として記録">✅</button>
            <button class="btn ghost" data-action="ng" title="誤答として記録">❌</button>
          </div>
        </div>
        <div class="answer" ${shown ? '' : 'style="display:none"'}>${pt.answer ?? pt.label ?? ''}</div>
      `;
      card.querySelector('[data-action="focus"]').addEventListener('click', () => {
        const m = state.markers[pt.id];
        if (m) map.setView(m.getLatLng(), Math.max(map.getZoom(), 0), { animate:true });
      });
      card.querySelector('[data-action="reveal"]').addEventListener('click', () => toggleReveal(pt.id));
      card.querySelector('[data-action="ok"]').addEventListener('click', () => markResult(pt.id,'correct',card));
      card.querySelector('[data-action="ng"]').addEventListener('click', () => markResult(pt.id,'wrong',card));
      els.qList.appendChild(card);
    });
  }

  // --- 正誤/表示制御 ---
  function markResult(id, result, card){
    state.results[id] = result; saveResults();
    if (result === 'correct') { card?.classList.remove('wrong'); card?.classList.add('correct'); }
    if (result === 'wrong')   { card?.classList.remove('correct'); card?.classList.add('wrong'); }
    refreshMarkersVisibility();
  }
  function reveal(id){ if (!state.revealed.has(id)) { state.revealed.add(id); saveRevealed(); renderList(); refreshMarkersVisibility(); } }
  function hide(id){ if (state.revealed.has(id)) { state.revealed.delete(id); saveRevealed(); renderList(); refreshMarkersVisibility(); } }
  function toggleReveal(id){ if (els.toggleAnswers.checked) return; if (state.revealed.has(id)) hide(id); else reveal(id); }

  // --- 編集モード（ドラッグで座標更新） ---
  function setEditMode(on){
    state.edit = !!on;
    els.editBtn.textContent = on ? '編集モード: ON' : '編集モード';
    Object.entries(state.markers).forEach(([id, marker]) => {
      if (!marker) return;
      if (marker.dragging) on ? marker.dragging.enable() : marker.dragging.disable();
    });
  }
  function onDrag(pt, e){
    const ll = e.target.getLatLng();
    pt.x = ll.lng; pt.y = ll.lat;
  }

  // --- JSON書き出し ---
  async function exportJSON(){
    if (!state.data) return;
    const text = JSON.stringify(state.data, null, 2);
    try {
      await navigator.clipboard.writeText(text);
      alert('JSONをクリップボードにコピーしました。');
    } catch (e) {
      const blob = new Blob([text], {type:'application/json'});
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'mapdata.json'; a.click();
    }
  }
  </script>
</body>
</html>
